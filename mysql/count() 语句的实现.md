## count(*) 语句的实现

在 MySQL 中不同的引擎, count(*)的实现方式不相同, 

* MyISAM 引擎把一个表的总行数存在了磁盘上, 因此如果执行 count(*) 的时候, 会直接返回这个数, 效率很高
* InnoDB 中, 执行 count(*) 操作的时候, 需要把数据一行一行地从引擎里面读出来, 然后累积计数

**如果在条件中使用了 where 条件计算时, MyISAM 也没有这么快**

为什么 InnoDB 不跟 M有ISAM 一样把数字存起来

: 因为即使在同一时刻的多个查询, 由于 多版本并发控制(MCVCC)的原因, InnoDB 表因该返回多少行也是不确定的.  用 count(*) 来解释一下, 

假设表 t 中有 10000 条记录, 设计三个并行的会话

* 会话 A 先启动事务并查询一次表的总行数
* 会话 B 启动十五, 插入一行记录后查询表的总行数
* 会话 C 先启动一个单独的语句, 插入一行记录后, 查询表的总行数

假设从上到下的时间顺序执行的, 同一行的语句是在同一时刻执行的. 



| 会话 A                                                | 会话 B                               | 会话 C                                 |
| ----------------------------------------------------- | ------------------------------------ | -------------------------------------- |
| begin;                                                |                                      |                                        |
| select count(*) from t;                               |                                      |                                        |
|                                                       |                                      | insert into t (插入一行语句);          |
|                                                       | begin;                               |                                        |
|                                                       | insert into t (插入一样语句);        |                                        |
| select count(*) from t;(返回 10000); 由于事务的隔离性 | select count(*) from t; (返回 10002) | select count(*) from t; //(返回 10001) |
|                                                       |                                      |                                        |

在最后一个时刻, 三个会话 A, B, C 会同时查询表 t 的总函数, 但拿到的结果却不相同.



**InnoDB**的事务设计有关系的, 因为数据库的默认隔离级别是可重复读, 在代码上通过多版本并发控, 也就是 MVCC 来实现的. 每一行记录都要判断是否对这个会话可见, 一次对于 count(*) 请求来说, InnoDB 只好把数据一行一行地读出依次判断, 可见的行才能够用于计算 "基于这个查询" 的表的总行数计算. 



**InnoDB** 是索引组织表, 主键索引树的**叶子节点是数据**, 而普通索引的**叶子节点是主键的值**, 所以, 普通索引树比主键索引树小很多. 对于 count(*) 这样的操作, 遍历那个索引树得到的逻辑结果都是一样的. 因此, MySql 优化器会找到最小的那棵树来遍历, 在保证逻辑正确的前提下, 尽量减少扫描

count(*) 走普通索引的扫描



`show table status ` 也是可以显示行数的, 但是输出的结果有误差, 

索引的通过是通过采样来估算的, 实际上 `TABLE_ROWS` 就是通过采样估算得到的, 因此它也是不准确的, 索引 使用 `show table status ` 来显示行数也是不能直接使用的

小结: 

* MyISAM 表虽然 count(*) 很快, 但是支持事务
* `show table status` 命令虽然返回很快, 但是不支持事务
* InnoDB 表直接 count(*) 会遍历全表, 虽然结果准确, 但是有性能问题

#### 不同 count 的用法

`select count (?) from t` , `count(*)`, `count(主键 id)`, `count(字段)` 和 `count(1)` 有哪些差别? 

> 一下的讨论都是在 InnoDB 引擎环境下

count() 是什么? 

**count()** 是一个聚合函数, 对于返回的结果集, 一行行地判断, 如果count() 函数的参数不是 `NULL` , 累计值就加 1, 否则不加. 随后返回累计值.



所以 , count(*), count(主键 id) 和 count(1) 都是表示返回满足条件的结果集的总行数; 而 count(字段), 则表示返回满足条件的数据行里面, 参数 "字段" 不为 NULL 的总个数. 

至于性能分析差别的时候, 记住几个原则就可以了

1. server 层要什么就给什么
2. InnoDB 只给必要的值
3. 现在的优化器只优化 count(*) 语义为 "取行数", 其他的 "显而易见" 的优化并没有做

????? 什么意思

##### 对于 count(主键 id) 来说

 InnoDB 引擎会遍历整张表, 把每一行的 id 的值都取出来, 返回个 server 层, server 层拿到 id 后, 判断是不能为空的, 就按行累加.



##### 对于 count(1) 来说

InnoDB 会遍历整张表, 但不取值, server 层返回对于每一行, 放一个数字 "1" 进去, 判断不可能为空的, 按行累加



##### 对于 count(字段) 来说

1. 如果这个 "字段" 定义为 not null 的话, 一行行地从记录里面读出这个字段, 判断不能为null, 按行累加
2. 如果这个 "字段" 定义允许为 null, 那么执行的时候, 判断有可能是 null, 还要把值取出来再判断一下, 不是 null 才累加.

##### 除 count(*) 是例外

并不会把字段全部取出来, 而是专门做了优化, 不取值, count(*) 肯定不是 null, 按行累加

按照效率来排序的话:

cout(字段) < count(主键id) < count(1) ≈ count(*)